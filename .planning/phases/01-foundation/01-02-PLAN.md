---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - prisma/schema.prisma
  - app/routes/api.webhooks.salla.ts
  - app/inngest/functions/webhook-process.ts
  - app/inngest/functions/index.ts
autonomous: true

must_haves:
  truths:
    - "Webhooks are stored in history before processing"
    - "Webhook processing is queued to Inngest, not inline"
    - "app.trial.expired marks merchant as EXPIRED"
    - "app.subscription.expired marks merchant as EXPIRED"
    - "store.updated updates merchant store info"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "WebhookHistory model"
      contains: "model WebhookHistory"
    - path: "app/routes/api.webhooks.salla.ts"
      provides: "Extended webhook handler with Inngest queueing"
      exports: ["action"]
    - path: "app/inngest/functions/webhook-process.ts"
      provides: "Webhook processing Inngest function"
      exports: ["processWebhook"]
  key_links:
    - from: "app/routes/api.webhooks.salla.ts"
      to: "app/inngest/client.ts"
      via: "inngest.send() call"
      pattern: "inngest\\.send"
    - from: "app/inngest/functions/webhook-process.ts"
      to: "prisma.merchant"
      via: "database updates"
      pattern: "db\\.merchant\\.(update|updateMany)"
    - from: "app/inngest/functions/index.ts"
      to: "app/inngest/functions/webhook-process.ts"
      via: "exports processWebhook"
      pattern: "processWebhook"
---

<objective>
Extend webhook handling with history storage, Inngest queueing, and support for all required Salla events.

Purpose: Current webhook handler processes events inline (blocking) and only handles app.installed/app.uninstalled. Phase 1 requires handling trial/subscription expiry, store updates, and storing webhook history for debugging. Queueing to Inngest prevents timeout issues.

Output: Complete webhook system that stores all events, queues to Inngest for async processing, and handles all Phase 1 required events.
</objective>

<execution_context>
@/Users/mostefaouim/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mostefaouim/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md

# Inngest setup from Plan 01 (this plan depends on it)
@app/inngest/client.ts
@app/inngest/types.ts
@app/inngest/functions/index.ts

# Existing webhook handler to extend
@app/routes/api.webhooks.salla.ts

# Database schema to extend
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add WebhookHistory model and run migration</name>
  <files>
    prisma/schema.prisma
  </files>
  <action>
1. Read existing `prisma/schema.prisma` first.

2. Add WebhookHistory model at the end of the file (after Product model):
   ```prisma
   // Webhook event history for debugging and audit
   model WebhookHistory {
     id              String    @id @default(cuid())
     merchantSallaId Int       @map("merchant_salla_id")
     event           String
     payload         Json
     status          WebhookStatus @default(RECEIVED)
     processedAt     DateTime?     @map("processed_at")
     error           String?
     receivedAt      DateTime  @default(now()) @map("received_at")

     @@index([merchantSallaId])
     @@index([event])
     @@index([receivedAt])
     @@map("webhook_history")
   }

   enum WebhookStatus {
     RECEIVED    // Received but not yet processed
     PROCESSING  // Currently being processed by Inngest
     PROCESSED   // Successfully processed
     FAILED      // Processing failed
   }
   ```

3. Run migration:
   ```bash
   npx prisma db push
   ```

IMPORTANT: Preserve all existing models (Merchant, Product) and enums. Only ADD the new WebhookHistory model and WebhookStatus enum.
  </action>
  <verify>
    - `grep "model WebhookHistory" prisma/schema.prisma` returns match
    - `grep "enum WebhookStatus" prisma/schema.prisma` returns match
    - `npx prisma validate` succeeds
    - `npx prisma db push` succeeds (or already applied)
  </verify>
  <done>
    WebhookHistory model added to schema with status tracking, indexes for efficient querying, and migration applied.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Inngest webhook processing function</name>
  <files>
    app/inngest/functions/webhook-process.ts
    app/inngest/functions/index.ts
  </files>
  <action>
1. Create `app/inngest/functions/webhook-process.ts`:
   ```typescript
   /**
    * Webhook Processing Inngest Function
    *
    * Processes Salla webhook events asynchronously with:
    * - Automatic retries on failure
    * - Status tracking in WebhookHistory
    * - All Phase 1 required event handlers
    *
    * @see https://docs.salla.dev/421413m0 (Salla App Events)
    */
   import { inngest } from "~/inngest/client";
   import { db } from "~/lib/db.server";

   // All Salla webhook event types we handle
   type SallaWebhookEvent =
     | "app.installed"
     | "app.uninstalled"
     | "app.store.authorize"
     | "app.trial.started"
     | "app.trial.expired"
     | "app.trial.canceled"
     | "app.subscription.started"
     | "app.subscription.expired"
     | "app.subscription.canceled"
     | "app.subscription.renewed"
     | "store.updated";

   export const processWebhook = inngest.createFunction(
     {
       id: "process-salla-webhook",
       retries: 3,
     },
     { event: "app/webhook.received" },
     async ({ event, step }) => {
       const { event: webhookEvent, merchantSallaId, payload, webhookHistoryId } = event.data;

       // Mark webhook as processing
       await step.run("mark-processing", async () => {
         await db.webhookHistory.update({
           where: { id: webhookHistoryId },
           data: { status: "PROCESSING" },
         });
       });

       try {
         // Process based on event type
         await step.run("process-event", async () => {
           switch (webhookEvent as SallaWebhookEvent) {
             case "app.installed": {
               await db.merchant.updateMany({
                 where: { sallaId: merchantSallaId },
                 data: {
                   status: "ACTIVE",
                   uninstalledAt: null,
                 },
               });
               console.log(`[Webhook] Merchant ${merchantSallaId} marked as ACTIVE`);
               break;
             }

             case "app.uninstalled": {
               const uninstallDate = (payload as { uninstallation_date?: string })?.uninstallation_date
                 ? new Date((payload as { uninstallation_date: string }).uninstallation_date)
                 : new Date();

               await db.merchant.updateMany({
                 where: { sallaId: merchantSallaId },
                 data: {
                   status: "UNINSTALLED",
                   uninstalledAt: uninstallDate,
                 },
               });
               console.log(`[Webhook] Merchant ${merchantSallaId} marked as UNINSTALLED`);
               break;
             }

             case "app.trial.expired":
             case "app.trial.canceled":
             case "app.subscription.expired":
             case "app.subscription.canceled": {
               // All these events mean merchant loses access
               await db.merchant.updateMany({
                 where: { sallaId: merchantSallaId },
                 data: { status: "EXPIRED" },
               });
               console.log(`[Webhook] Merchant ${merchantSallaId} marked as EXPIRED (${webhookEvent})`);
               break;
             }

             case "app.trial.started":
             case "app.subscription.started":
             case "app.subscription.renewed": {
               // All these events mean merchant has active access
               await db.merchant.updateMany({
                 where: { sallaId: merchantSallaId },
                 data: { status: "ACTIVE" },
               });
               console.log(`[Webhook] Merchant ${merchantSallaId} marked as ACTIVE (${webhookEvent})`);
               break;
             }

             case "store.updated": {
               // Update merchant store info
               const storeData = payload as {
                 name?: string;
                 domain?: string;
                 email?: string;
               };

               await db.merchant.updateMany({
                 where: { sallaId: merchantSallaId },
                 data: {
                   ...(storeData.name && { storeName: storeData.name }),
                   ...(storeData.domain && { storeUrl: storeData.domain }),
                   ...(storeData.email && { email: storeData.email }),
                 },
               });
               console.log(`[Webhook] Merchant ${merchantSallaId} store info updated`);
               break;
             }

             case "app.store.authorize": {
               // Informational only - OAuth callback handles this
               console.log(`[Webhook] Merchant ${merchantSallaId} authorized (info only)`);
               break;
             }

             default: {
               console.log(`[Webhook] Unhandled event: ${webhookEvent}`);
             }
           }
         });

         // Mark webhook as processed
         await step.run("mark-processed", async () => {
           await db.webhookHistory.update({
             where: { id: webhookHistoryId },
             data: {
               status: "PROCESSED",
               processedAt: new Date(),
             },
           });
         });

         return { status: "processed", event: webhookEvent };

       } catch (error) {
         // Mark webhook as failed
         await db.webhookHistory.update({
           where: { id: webhookHistoryId },
           data: {
             status: "FAILED",
             error: error instanceof Error ? error.message : "Unknown error",
           },
         });

         throw error; // Re-throw for Inngest retry
       }
     }
   );
   ```

2. Update `app/inngest/functions/index.ts` to export the function:
   ```typescript
   // Export all Inngest functions
   import { processWebhook } from "./webhook-process";

   export const functions = [processWebhook];
   ```
  </action>
  <verify>
    - File exists: `app/inngest/functions/webhook-process.ts`
    - `grep "processWebhook" app/inngest/functions/index.ts` returns match
    - TypeScript compiles: `npx tsc --noEmit`
    - All event types covered: `grep -E "app\.(installed|uninstalled|trial\.|subscription\.)|store\.updated" app/inngest/functions/webhook-process.ts | wc -l` shows multiple matches
  </verify>
  <done>
    Inngest function created that handles all Phase 1 webhook events with status tracking and proper retry behavior.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update webhook handler to store history and queue to Inngest</name>
  <files>
    app/routes/api.webhooks.salla.ts
  </files>
  <action>
1. Replace `app/routes/api.webhooks.salla.ts` with updated version that:
   - Stores webhook in history FIRST
   - Queues to Inngest for async processing
   - Returns 200 immediately (no blocking)

   ```typescript
   /**
    * Salla Webhooks Handler
    *
    * Handles webhook events from Salla by:
    * 1. Verifying signature
    * 2. Storing in WebhookHistory
    * 3. Queueing to Inngest for async processing
    * 4. Returning 200 immediately
    *
    * POST /api/webhooks/salla
    *
    * @see https://docs.salla.dev/doc-421119
    */

   import type { ActionFunctionArgs } from "react-router";
   import { createHmac, timingSafeEqual } from "crypto";
   import { db } from "~/lib/db.server";
   import { inngest } from "~/inngest/client";

   interface SallaWebhookPayload {
     event: string;
     merchant: number;
     created_at: string;
     data: Record<string, unknown>;
   }

   /**
    * Verify webhook signature using HMAC-SHA256
    */
   function verifySignature(payload: string, signature: string, secret: string): boolean {
     if (!signature || !secret) {
       return false;
     }

     const computedSignature = createHmac("sha256", secret)
       .update(payload)
       .digest("hex");

     try {
       return timingSafeEqual(
         Buffer.from(signature),
         Buffer.from(computedSignature)
       );
     } catch {
       return false;
     }
   }

   export async function action({ request }: ActionFunctionArgs) {
     // Only accept POST requests
     if (request.method !== "POST") {
       return Response.json({ error: "Method not allowed" }, { status: 405 });
     }

     // Get raw body for signature verification
     const rawBody = await request.text();

     // Verify signature
     const signature = request.headers.get("x-salla-signature");
     const webhookSecret = process.env.SALLA_WEBHOOK_SECRET;

     if (!webhookSecret) {
       console.error("[Webhook] SALLA_WEBHOOK_SECRET not configured");
       if (process.env.NODE_ENV === "production") {
         return Response.json({ error: "Webhook secret not configured" }, { status: 500 });
       }
     } else if (!verifySignature(rawBody, signature || "", webhookSecret)) {
       console.error("[Webhook] Invalid signature");
       return Response.json({ error: "Invalid signature" }, { status: 401 });
     }

     // Parse the payload
     let payload: SallaWebhookPayload;
     try {
       payload = JSON.parse(rawBody);
     } catch {
       console.error("[Webhook] Invalid JSON payload");
       return Response.json({ error: "Invalid JSON" }, { status: 400 });
     }

     const { event, merchant: sallaId, data } = payload;

     console.log(`[Webhook] Received event: ${event} for merchant: ${sallaId}`);

     try {
       // 1. Store webhook in history
       const webhookHistory = await db.webhookHistory.create({
         data: {
           merchantSallaId: sallaId,
           event,
           payload: payload as object,
           status: "RECEIVED",
         },
       });

       // 2. Queue for async processing via Inngest
       await inngest.send({
         name: "app/webhook.received",
         data: {
           event,
           merchantSallaId: sallaId,
           payload: data,
           webhookHistoryId: webhookHistory.id,
         },
       });

       console.log(`[Webhook] Queued event ${event} for processing (history: ${webhookHistory.id})`);

     } catch (error) {
       // Log but don't fail - we want to acknowledge receipt
       console.error("[Webhook] Failed to store/queue:", error);
       // Still return 200 to prevent Salla retry storm
       // The webhook will be missing from history but that's better than retry loops
     }

     // Always return 200 immediately
     return Response.json({ success: true, event });
   }
   ```
  </action>
  <verify>
    - `grep "inngest.send" app/routes/api.webhooks.salla.ts` returns match
    - `grep "webhookHistory.create" app/routes/api.webhooks.salla.ts` returns match
    - TypeScript compiles: `npx tsc --noEmit`
    - No inline event processing (switch statement removed): `grep -c "case.*app.installed" app/routes/api.webhooks.salla.ts` returns 0
  </verify>
  <done>
    Webhook handler updated to store history and queue to Inngest - no more blocking inline processing.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Schema validation:**
   ```bash
   npx prisma validate
   ```
   Should succeed with WebhookHistory model.

2. **TypeScript compilation:**
   ```bash
   npx tsc --noEmit
   ```
   No errors.

3. **Inngest function registration:**
   ```bash
   grep "processWebhook" app/inngest/functions/index.ts
   ```
   Should show export.

4. **Webhook handler structure:**
   ```bash
   grep -E "webhookHistory|inngest.send" app/routes/api.webhooks.salla.ts
   ```
   Should show both patterns.

5. **Build check:**
   ```bash
   npm run build
   ```
   Build should succeed.

6. **Event coverage:**
   ```bash
   grep -E "app\.(trial|subscription)\.(expired|canceled)" app/inngest/functions/webhook-process.ts
   ```
   Should show all expiry events handled.
</verification>

<success_criteria>
- WebhookHistory model exists in schema with status tracking
- Migration applied successfully
- Webhook handler stores to history before queueing
- Webhook handler returns 200 immediately (no blocking)
- Inngest function processes all Phase 1 required events:
  - app.installed (marks ACTIVE)
  - app.uninstalled (marks UNINSTALLED)
  - app.trial.expired (marks EXPIRED)
  - app.subscription.expired (marks EXPIRED)
  - store.updated (updates store info)
- All TypeScript compiles and builds
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
