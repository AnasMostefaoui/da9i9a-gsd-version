---
phase: 02-product-scraping
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - app/services/scraping/cost-tracker.server.ts
  - app/services/scraping/orchestrator.server.ts
  - prisma/schema.prisma
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Every scrape records provider name and estimated cost"
    - "Cost stored in product metadata for later aggregation"
    - "Merchant usage can be summed for subscription enforcement"
  artifacts:
    - path: "app/services/scraping/cost-tracker.server.ts"
      provides: "Cost estimation and tracking utilities"
      exports: ["estimateScrapeCost", "PROVIDER_COSTS"]
    - path: "prisma/schema.prisma"
      provides: "Updated Product model metadata structure"
      contains: "scrapeCost"
  key_links:
    - from: "app/services/scraping/orchestrator.server.ts"
      to: "app/services/scraping/cost-tracker.server.ts"
      via: "Cost calculation after successful scrape"
      pattern: "estimateScrapeCost.*provider"
---

<objective>
Implement cost tracking for scraping operations to enable subscription tier enforcement in Phase 5.

Purpose: Different scraping providers have different costs. Tracking cost per product allows enforcing usage limits (e.g., "Free tier: 10 products/month"). This data feeds into the subscription system in Phase 5.

Output: Cost estimation utilities, updated orchestrator to record costs, metadata schema for cost storage.
</objective>

<execution_context>
@/Users/mostefaouim/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mostefaouim/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-product-scraping/02-CONTEXT.md

# Orchestrator to modify
@app/services/scraping/orchestrator.server.ts
@app/services/scraping/types.ts

# Database schema
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cost tracking service</name>
  <files>
    app/services/scraping/cost-tracker.server.ts
  </files>
  <action>
Create `app/services/scraping/cost-tracker.server.ts`:

1. Define cost constants per provider (estimated per-request cost):
```typescript
export const PROVIDER_COSTS = {
  apify: {
    aliexpress: 0.015,  // ~$15 per 1000 requests
    amazon: 0.020,      // ~$20 per 1000 requests
  },
  oxylabs: {
    aliexpress: 0.025,  // ~$25 per 1000 requests
    amazon: 0.020,      // ~$20 per 1000 requests
  },
  vision: 0.005,        // Gemini Vision (when used as fallback)
} as const;
```

2. Function `estimateScrapeCost(provider: string, platform: Platform): number`
   - Returns estimated cost in USD
   - Handle hybrid providers like "apify+vision" by summing components

3. Type for cost metadata:
```typescript
export interface ScrapeCostMetadata {
  provider: string;
  platform: string;
  estimatedCostUsd: number;
  scrapedAt: string;  // ISO timestamp
  duration: number;   // milliseconds
}
```

4. Function `formatCostForDisplay(costUsd: number): string`
   - Returns formatted string like "$0.02" or "< $0.01"
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Exports exist: `grep "export.*estimateScrapeCost\|PROVIDER_COSTS" app/services/scraping/cost-tracker.server.ts`
  </verify>
  <done>
Cost tracker provides estimation and formatting utilities.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate cost tracking into orchestrator</name>
  <files>
    app/services/scraping/orchestrator.server.ts
  </files>
  <action>
Modify `app/services/scraping/orchestrator.server.ts`:

1. Import cost tracker:
```typescript
import { estimateScrapeCost, type ScrapeCostMetadata } from "./cost-tracker.server";
```

2. Update `scrapeProduct()` return type to include cost metadata:
   - Add `costMetadata?: ScrapeCostMetadata` to ScrapedProduct interface in types.ts
   - Or return a wrapper: `{ product: ScrapedProduct, cost: ScrapeCostMetadata }`

3. After successful scrape, calculate and attach cost:
```typescript
const cost: ScrapeCostMetadata = {
  provider: product.provider,
  platform,
  estimatedCostUsd: estimateScrapeCost(product.provider, platform),
  scrapedAt: new Date().toISOString(),
  duration: totalDuration,
};
product.costMetadata = cost;
```

4. Log cost for observability:
```typescript
console.log(`[Orchestrator] Scrape cost: $${cost.estimatedCostUsd.toFixed(4)} (${cost.provider})`);
```

This ensures every successful scrape has cost data attached, which will be stored in Product.metadata by the import route or Inngest function.
  </action>
  <verify>
Cost import exists: `grep "estimateScrapeCost" app/services/scraping/orchestrator.server.ts`
Cost logging exists: `grep "Scrape cost" app/services/scraping/orchestrator.server.ts`
  </verify>
  <done>
Orchestrator calculates and attaches cost metadata to every scrape.
  </done>
</task>

<task type="auto">
  <name>Task 3: Document metadata schema for cost storage</name>
  <files>
    prisma/schema.prisma
  </files>
  <action>
Add a comment to `prisma/schema.prisma` documenting the expected metadata structure:

In the Product model, above the `metadata` field, add:
```prisma
// Additional metadata (scraping info, brand, SKU, cost tracking, etc.)
// Expected structure:
// {
//   scrapedAt: string,
//   provider: string,
//   brand?: string,
//   sku?: string,
//   reviewSummary?: { rating: number, count: number },
//   seller?: { name: string, rating?: number },
//   scrapeCost?: {
//     provider: string,
//     platform: string,
//     estimatedCostUsd: number,
//     scrapedAt: string,
//     duration: number
//   },
//   aiProvider?: string,
//   aiGeneratedAt?: string,
//   highlights?: string[],
//   highlightsAr?: string[]
// }
metadata        Json?     @default("{}")
```

This is documentation only - JSON fields are schemaless by design. The comment helps future developers understand the expected structure.

No migration needed since metadata is already a Json field.
  </action>
  <verify>
Comment exists: `grep -A5 "cost tracking" prisma/schema.prisma`
  </verify>
  <done>
Metadata schema documented for future reference.
  </done>
</task>

</tasks>

<verification>
1. Import a product and check logs show cost estimation
2. Query product metadata and verify scrapeCost field exists
3. Test with different providers (Apify vs Oxylabs) - costs should differ
4. Verify vision fallback adds its cost component
</verification>

<success_criteria>
- Every scraped product has cost metadata in Product.metadata.scrapeCost
- Cost varies by provider and platform as expected
- Hybrid scrapes (provider+vision) sum component costs
- Cost values are reasonable (< $0.10 per product)
</success_criteria>

<output>
After completion, create `.planning/phases/02-product-scraping/02-03-SUMMARY.md`
</output>
