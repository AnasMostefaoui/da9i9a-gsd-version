---
phase: 02-product-scraping
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/inngest/functions/scrape-product.ts
  - app/inngest/functions/index.ts
  - app/inngest/types.ts
  - app/routes/import.tsx
  - app/routes/api.scrape-status.$jobId.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "User submits URL and sees immediate feedback (job queued)"
    - "Scraping runs in background without blocking UI"
    - "User can poll job status and see progress"
    - "Completed job redirects to product page"
    - "Failed jobs show error and allow retry"
  artifacts:
    - path: "app/inngest/functions/scrape-product.ts"
      provides: "Async scraping job handler"
      exports: ["scrapeProduct"]
    - path: "app/routes/api.scrape-status.$jobId.ts"
      provides: "Job status polling endpoint"
      exports: ["loader"]
  key_links:
    - from: "app/routes/import.tsx"
      to: "inngest.send"
      via: "Event dispatch on form submit"
      pattern: "inngest\\.send.*product/scrape\\.requested"
    - from: "app/inngest/functions/scrape-product.ts"
      to: "orchestrator.scrapeProduct"
      via: "Function invocation"
      pattern: "getScrapingOrchestrator.*scrapeProduct"
---

<objective>
Implement async scraping via Inngest to prevent UI blocking during long-running scrape jobs.

Purpose: Current synchronous scraping blocks the UI for 30-60+ seconds. Users see a spinning loader with no feedback. Inngest queuing enables immediate response, progress tracking, and automatic retries.

Output: Inngest function for scraping, status polling endpoint, updated import route that queues jobs instead of blocking.
</objective>

<execution_context>
@/Users/mostefaouim/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mostefaouim/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-product-scraping/02-CONTEXT.md

# Existing Inngest setup
@app/inngest/client.ts
@app/inngest/types.ts
@app/inngest/functions/index.ts

# Existing scraping implementation
@app/services/scraping/orchestrator.server.ts
@app/services/scraping/types.ts
@app/routes/import.tsx

# Retry utilities
@app/lib/retry.server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Inngest scrape-product function</name>
  <files>
    app/inngest/functions/scrape-product.ts
    app/inngest/functions/index.ts
    app/inngest/types.ts
  </files>
  <action>
Create `app/inngest/functions/scrape-product.ts`:

1. Define Inngest function triggered by `product/scrape.requested` event
2. Use step.run() for scraping operation (enables retries)
3. Flow:
   - Load product by ID (should exist with status IMPORTING)
   - Call `getScrapingOrchestrator().scrapeProduct(url)`
   - On success: Update product with scraped data, set status to IMPORTED
   - On failure: Set status to FAILED, store error in metadata

Use existing RetryPresets.scraper configuration for retries (already defined in app/lib/retry.server.ts - 3 attempts, 5s starting delay).

Update `app/inngest/types.ts`:
- Add `product/scrape.completed` event type with productId and success boolean
- Add `product/scrape.failed` event type with productId and error string

Update `app/inngest/functions/index.ts`:
- Import and export the new scrapeProduct function

Key implementation details:
- Use `step.run("scrape-product", async () => {...})` for automatic retry on failure
- Store scraping provider and duration in product metadata for cost tracking
- Handle partial success (images but no text) by continuing with AI fallback in Phase 3
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Function exists in registry: grep for "scrapeProduct" in functions/index.ts
  </verify>
  <done>
Inngest function handles `product/scrape.requested` events and updates product status accordingly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create job status polling endpoint</name>
  <files>
    app/routes/api.scrape-status.$jobId.ts
  </files>
  <action>
Create `app/routes/api.scrape-status.$jobId.ts`:

This is a React Router 7 resource route (no default export, only loader).

1. Accept jobId parameter (which is the product ID)
2. Query Product by ID
3. Return JSON with:
   - status: Product.status (IMPORTING, IMPORTED, ENHANCED, FAILED)
   - productId: for redirect on completion
   - error: from metadata.scrapeError if status is FAILED

Response format:
```json
{
  "status": "IMPORTING" | "IMPORTED" | "ENHANCED" | "FAILED",
  "productId": "clx...",
  "error": null | "Error message"
}
```

Security: Only allow merchant to check their own products (use requireMerchant and verify product.merchantId).

Use React Router 7 patterns:
- Export `loader` function (not action, this is read-only)
- Return `Response.json()` or use data() from react-router
  </action>
  <verify>
File exists and exports loader: `grep -l "export.*loader" app/routes/api.scrape-status.*`
  </verify>
  <done>
Status endpoint returns current job status for polling.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update import route for async flow</name>
  <files>
    app/routes/import.tsx
  </files>
  <action>
Modify `app/routes/import.tsx` action to queue Inngest job instead of blocking:

1. Keep URL validation (detectPlatform check)
2. Create Product with status IMPORTING (not IMPORTED)
3. Send Inngest event:
   ```ts
   import { inngest } from "~/inngest/client";

   await inngest.send({
     name: "product/scrape.requested",
     data: {
       productId: product.id,
       sourceUrl: url,
       merchantId,
     }
   });
   ```
4. Return redirect to new polling page: `/import/status/${product.id}`

Create simple polling UI in the component:
- If route is `/import/status/:jobId`, show polling state
- Poll `/api/scrape-status/{jobId}` every 2 seconds
- Show progress indicator with "Scraping product..." message
- On status IMPORTED or ENHANCED: redirect to `/products/${productId}`
- On status FAILED: show error with retry button

Alternative approach (simpler): Create separate route `app/routes/import.status.$jobId.tsx` for the polling page. This keeps import.tsx clean and focused.

Key changes:
- Remove synchronous orchestrator.scrapeProduct() call from action
- Remove AI enhancement from action (will happen in Inngest function later)
- Return redirect to status page instead of product page
  </action>
  <verify>
Action creates product with IMPORTING status: grep for "status.*IMPORTING" in import.tsx
Inngest send is called: grep for "inngest.send" in import.tsx
  </verify>
  <done>
Import submits job and redirects to polling page. User sees progress and gets redirected on completion.
  </done>
</task>

</tasks>

<verification>
1. Submit a product URL through the import form
2. See immediate redirect to status page (not blocking)
3. Status page polls and shows "Scraping..."
4. After Inngest processes, status changes to IMPORTED
5. Auto-redirect to product page
6. Check Inngest dashboard shows the job execution
</verification>

<success_criteria>
- Product import no longer blocks UI for 30+ seconds
- User sees immediate feedback after submitting URL
- Polling shows real-time status updates
- Failed jobs display error and allow retry
- Inngest dashboard shows successful job execution
</success_criteria>

<output>
After completion, create `.planning/phases/02-product-scraping/02-01-SUMMARY.md`
</output>
